{
  "name": "climap",
  "version": "0.1.1",
  "author": {
    "name": "Simon Lydell"
  },
  "license": "LGPLv3",
  "description": "Super simple source map generation for CLI tools.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/lydell/climap"
  },
  "homepage": "https://github.com/lydell/climap",
  "bugs": {
    "url": "https://github.com/lydell/climap/issues"
  },
  "keywords": [
    "cli",
    "source map"
  ],
  "scripts": {
    "test": "jshint index.js example/ test/ && mocha"
  },
  "dependencies": {
    "source-map": "~0.1.29"
  },
  "devDependencies": {
    "mocha": "~1.13.0",
    "chai": "~1.8.0",
    "sinon": "~1.7.3",
    "sinon-chai": "~2.4.0",
    "css-parse": "lydell/css-parse#source",
    "sheet": "lydell/sheet#mine",
    "jshint": "~2.1.11",
    "rimraf": "~2.2.2"
  },
  "readme": "[![Build Status](https://travis-ci.org/lydell/climap.png?branch=master)](https://travis-ci.org/lydell/climap)\r\n\r\nOverview\r\n========\r\n\r\nHave you added source map support to your compiler, but aren't sure about how to expose it to your\r\nCLI tool? Keep it simple! Add a `--map` switch and let Climap do the rest!\r\n\r\nIn order to make it so simple, Climap enforces some conventions. A source map for a file \"foo.js\"\r\nwill:\r\n\r\n- be called \"foo.js.map\",\r\n- be placed next to \"foo.js\",\r\n- have all its sources listed relative to itself,\r\n- have source maps of its source files applied to itself. (Takes care of \"in source maps\".)\r\n\r\n\r\nInstallation\r\n============\r\n\r\n`npm install climap`\r\n\r\n```js\r\nvar Climap = require(\"climap\")\r\n```\r\n\r\n\r\nUsage\r\n=====\r\n\r\nGiven an array `files` of paths to input files, an output path `output`, some parsing, compiling,\r\nmerging and joining functions `parse`, `compile`, `merge` and `join`, respectively, and a flag\r\n`useStdout`:\r\n\r\nIf each file should be processed on its own:\r\n\r\n```js\r\nfiles.forEach(function(file) {\r\n\tClimap(file, join(output, file))\r\n\t\t.parse(function(content, source, index, sources) {\r\n\t\t\treturn parse(content, source)\r\n\t\t})\r\n\t\t.compile(function(ast, data) {\r\n\t\t\tvar compiled = compile(ast, {\r\n\t\t\t\tfile: data.file,\r\n\t\t\t\tsourceMappingURL: data.sourceMappingURL,\r\n\t\t\t\tsourceRoot: data.sourceRoot\r\n\t\t\t})\r\n\t\t\treturn {content: compiled.content, map: compiled.map}\r\n\t\t})\r\n\t\t.write(function(compiled, map) {\r\n\t\t\tif (useStdout) {\r\n\t\t\t\tprocess.stdout.write(compiled)\r\n\t\t\t\treturn true // Indicate that no file should be written.\r\n\t\t\t}\r\n\t\t})\r\n})\r\n```\r\n\r\nIf all the files should be processed together:\r\n\r\n```js\r\nClimap(files, output)\r\n\t.parse(parse)\r\n\t.reduce(function(merged, current, index, array) {\r\n\t\treturn merge(merged, current)\r\n\t})\r\n\t.compile(compile)\r\n\t.write()\r\n```\r\n\r\nClimap was all about source map generation, right? Why do I have to write the whole\r\nread–parse–compile–write chain with Climap in the back all the time? Good question. The answer is\r\nthat Climap needs to gather and exchange information during the whole process. It's also about\r\nconvenience.\r\n\r\nNote\r\n----\r\n\r\n### `Climap` ###\r\n\r\nThe first argument of `Climap` can be either a string, or an array of strings, as seen. If a non\r\narray string is passed, reducing is not mandatory (and probably useless). The strings are paths to\r\nfiles, which will be read. You may also pass `{source: \"path/to/file\", content: \"content of file\"}`\r\nobjects instead of strings, or mix both variants.\r\n\r\n`Climap` is actually a constructor. You may use the `new` keyword before it if you wish. You can of\r\ncourse also assign the instance to a variable if you so desire, but all the relevant methods are\r\nchainable, so there's really no need to.\r\n\r\n### The parsing function ###\r\n\r\n`source` is a shortened form of each file path, optimized to be used in a source map. The parser\r\nshould put that in the AST it creates.\r\n\r\n### The compiling function ###\r\n\r\n`data.file` is the basename of the to-be-written output file (second parameter passed to `Climap`).\r\n\r\n`data.sourceMappingURL` is actually just `data.file + \".map\"`. The compiler should put it in the `#\r\nsourceMappingURL=...` comment at the end of the file. `Climap` cannot do this automatically, since\r\nit cannot now what language you are targeting and thus doesn't know the correct comment syntax.\r\n\r\nNote that the above means that the source map must always be kept in the same directory as its file.\r\nThat assumption is made for simplicity.\r\n\r\nFinally, `data.sourceRoot` is automatically populated to reduces the size of `sources` array in the\r\nsource map as much as possible. It is relative to the source map itself.\r\n\r\n### The writing function ###\r\n\r\nAs seen, it is optional. If omitted, or if it returns something falsy, the output file (second\r\nparameter passed to `Climap`) will be written, along with its source map (if any). Usually that's\r\nwhat you want, but you are given the opportunity to opt out here.\r\n\r\n### The reducing function ###\r\n\r\n`Climap#reduce` is exactly like `Array#reduce` (you may also pass an initial value, if you wish).\r\n\r\n### Comprehensive example ###\r\n\r\nSee [example/css-minify-concat.js](example/css-minify-concat.js). It is a little CLI tool that\r\nminifies and concatenates CSS files. Try it out: `node example/css-minify-concat.js --map\r\ntest/files/source?.css bundle.css`.\r\n\r\n\r\nLicenses\r\n========\r\n\r\nLGPLv3 in general. The example program is GPLv3. All files which do not mention anything about\r\ncopyright and licenses are public domain.\r\n",
  "readmeFilename": "readme.md",
  "_id": "climap@0.1.1",
  "_from": "climap@~0.1.1"
}
